---
title: OSI 7 계층
excerpt: "study 3회차 - cs"

categories:
  - ETC

permalink: /etc/3/

toc: true
toc_sticky: true
 
date: 2024-03-18
last_modified_at: 2024-03-19
---

# OSI 7 계층이란?

[네트워크](http://wiki.hash.kr/index.php/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC) [프로토콜](http://wiki.hash.kr/index.php/%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)이 [통신](http://wiki.hash.kr/index.php/%ED%86%B5%EC%8B%A0)하는 구조를 7개의 계층으로 분리하여 각 계층간 상호 작동하는 방식을 정해 놓은 것이다.

> **프로토콜**은 둘 이상의 통신 개체 간에 교환되는 메시지 포맷과 순서뿐만 아니라, 메시지의 송수신과 다른 이벤트에 따른 행동들을 정의한다.
> 
> 
> ![Untitled](/assets/images/2024-03-19-OSI-7/Untitled.png)
> 

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%201.png)

각 계층은 그 **계층 내부에서 어떤 동작을 수행**하거나, **직접 하위 계층의 서비스를 사용**한다.

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%202.png)

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%203.png)

## 7. 응용 계층

애플리케이션 계층은 네트워크 애플리케이션과 애플리케이션 계층 프로토콜이 있는 곳이다.

- 프로토콜
    - HTTP(웹 문서 요청과 전송 제공)
        - 웹의 애플리케이션 계층 프로토콜
        - 클라이언트 - 서버 구조
        - TCP를 전송 프로토콜로 사용
    - SMTP(전자메일 전송 제공)
    - FTP(두 종단 시스템 간의 파일 전송 제공)

**각 종단 시스템의 네트워크 애플리케이션끼리는 위의 프로토콜로 정보 패킷을 교환한다. 그리고 애플리케이션 계층에서 이 정보 패킷을 메시지(message)라고 한다.**

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%204.png)

### PDU

네트워크의 어떠한 계층에서 계층으로 데이터가 전달될 떄 한 덩어리의 단위를 PDU(Protocol Data Unit)라고 한다.

- ‘패킷’이라고 전체적으로 말하기도 함.
- 헤더 필드와 페이로드 필드라는 두 가지 형태의 필드를 가짐.
    - 헤더 - 각 계층마다 필요한 정보들이 담김
    - 페이로드 - 송신 측에서 보내고자 하는 데이터

## 6. 표현 계층

위에서 각 계층은 계층 내부에서 어떤 동작을 수행하기 위해 하위 계층의 서비스를 사용할 수 있다고 했다. **표현 계층은 상,하위 계층에서 데이터를 받아 반대 계층에 맞게 데이터를 변환하는 동작을 수행한다. 즉, 전송하는 데이터의 인코딩 및 디코딩이 이루어지는 계층이라고 볼 수 있다.**

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%205.png)

- **표현 계층의 프로토콜**
    - SSL(디지털 인증서)
    - ASCII
    - JPEG(이미지)
    - MPEG(멀티미디어(비디오, 오디오))

## 5. 세션 계층

**세션 계층은 응용 프로그램간의 연결, 유지, 종료를 관리한다.**

- 포트 번호를 기반으로 연결
- 두 프로세스 간의 대화를 관리하는 특수한 메시지 사용 - 토큰
- 에러가 발생하면 동기화 지점을 두어 데이터 손실을 복원한다.

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%206.png)

- 동시 송수신 방식 :duplex
    
    > 두 대의 단말기가 데이터를 송수신하기 위해 동시에 각각 독립된 회선을 사용하는 통신 방식
    > 
- 반이중 방식 : half-duplex
    
    > 두개의 통신장치가 각각의 방향으로 양방향 통신을 할수는 있지만 한번에 한쪽방향으로만 통신이 가능한 통신방식
    > 
- 전이중 방식 : Full Duplex
    
    > 두개의 통신장치가 동시에 통신이 가능한 통신방식
    ex) socket
    > 

## 4. 전송 계층

전송 계층은 클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공한다.

**애플리케이션 메시지 → 세그먼트로 캡슐화 → 네트워크 계층으로 전달**

### 캡슐화/역캡슐화

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%207.png)

캡슐화/역캡슐화는 각 계층에서 필요한 추가정보들을 패킷에 더하는 것을 뜻합니다. 전송 계층에서 패킷은 세그먼트가 되겠습니다.

이때 추가정보는 **트랜스포트 계층 헤더 정보**라고 하며 그림에서는 Ht입니다.

**애플리케이션 계층 메시지 +** **트랜스포트 계층 헤더 정보 =** **트랜스포트 계층 세그먼트**

- **트랜스포트 계층 세그먼트**는 **애플리케이션 계층 메시지를 캡슐화**합니다.
- **추가된 정보**는 수신 측의 트랜스포트 계층이 그 메시지를 적절한 애플리케이션으로 보내도록 하는 정보와 메시지의 비트들이 변경되었는지 아닌지를 수신자가 결정하게 하는 **오류 검출 비트를 포함**합니다.
- 그다음에 **트랜스포트 계층**은 **세그먼트를 네트워크 계층으로 보냅니다.**
- **네트워크 계층**은 출발지와 목적지 종단 시스템 주소와 동일한 **헤더 정보(그림에서 Hn)**를 추가하여 **네트워크 계층 데이터그램**을 만듭니다.
- 이 **데이터그램**은 **링크 계층으로 전달**되고 **링크 계층**도 **자신 헤더 정보를 추가**하고 **링크 계층 프레임**을 만듭니다.

**인터넷에는 두 가지 트랜스포트 계층 프로토콜이 존재한다.**

- **TCP**
    - 애플리케이션에게 **연결 지향형 서비스**를 제공한다. 이 서비스는 목적지로의 **애플리케이션 계층 메시지 전달 보장과 흐름 제어(송신자/수신자의 속도 일치)**를 포함한다.
    - 긴 메시지를 짧은 메시지로 나누고 **혼잡 제어** 기능을 제공한다.
        - 혼잡 제어 : 한 TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 혼잡하게 하는 것을 방지하는 것.
        - 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하게 해줌.
    - **3-way-handshake**
    - **4-way-handshake**
    
    ![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%208.png)
    
    ![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%209.png)
    
    - **SYN(Synchronization)** : 연결요청, 세션을 설정하는데 사용되며 초기에 시퀀스 번호를 보냄
    - **ACK(Acknowledgement)** : 보낸 시퀀스 번호에 TCP 계층에서의 길이 또는 양을 더한 것과 같은 값을 ACK에 포함하여 전송
        - 동기화 요청에 대한 답변 : `Client의 Sequence Number+1`을 하여 ACK로 돌려줍니다.
    - **Step 1 (SYN)**
        
        **클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다. (seq : x)**
        
        - 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
        - PORT 상태
            - Client : `CLOSED``SYN_SENT` 로 변함
            - Server : `LISTEN`
    - **Step 2 (SYN + ACK)**
        
        **서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (seq : y, ACK : x + 1)**
        
        - 접속요청을 받은 Q가 요청을 수락했으며, 접속 요청 프로세스인 P도 포트를 열어달라는 메세지를 전송 (SYN-ACK signal bits set)
        - ACK Number필드를 Sequence Number + 1 로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 새그먼트 전송 (`Seq=y, Ack=x+1, SYN, ACK`)
        - PORT 상태
            - Client : `CLOSED`
            - Server : `SYN_RCV`
    - **Step 3 (ACK)**
        
        **클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1)를 서버로 보냄**
        
        - 마지막으로 접속 요청 프로세스 P가 수락 확인을 보내 연결을 맺음 (ACK)
        - 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
        - PORT 상태
            - Client : `ESTABLISED`
            - Server : `SYN_RCV` ⇒ ACK ⇒ `ESTABLISED`
    
    `FIN` (finish) : 세션을 종료시키는데 사용되며, 더 이상 보낸 데이터가 없음을 나타낸다.
    
    - **STEP1 (Client → Server : FIN(+ACK)**
        - 서버와 클라이언트가 연결된 상태에서 클라이언트가 close()를 호출하여 접속을 끊는다.(으려한다.)
        - 이때, 클라이언트는 서버에게 연결을 종료한다는 `FIN` 플래그를 보낸다.
            - 이때 FIN 패킷에는 실질적으로 ACK도 포함되어있다.
    - **STEP2 (Server → Client : ACK)**
        - 서버는 FIN을 받고, 확인했다는 `ACK`를 클라이언트에게 보내고 자신의 통신이 끝날때까지 기다린다. (이상태가 TIME_WAIT 상태)
            - Server(수신자)는 ACK Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
        - 서버는 클라이언트에게 응답을 보내고 **`CLOSE_WAIT` 상태**에 들어갑니다. 그리고**아직 남은 데이터가 있다면 마저 전송을 마친 후에 close( )를 호출**
        - 클라이언트에서는 서버에서 ACK를 받은 후에 서버가 남은 데이터 처리를 끝내고 FIN 패킷을 보낼 때까지 기다리게 됩니다. (**`FIN_WAIT_2`)**
    - **STEP3 (Server → Client : FIN)**
        - 데이터를 모두 보냈다면, 서버는 연결이 종료에 합의 한다는 의미로 `FIN` 패킷을 클라이언트에게 보낸 후에, 승인 번호를 보내줄 때까지 기다니는 `LAST_ACK` 상태로 들어간다.
    - **STEP4 (Client → Server : ACK)**
        - 클라이언트는 FIN을 받고, 확인했다는 `ACK`를 서버에게 보낸다.
        - 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 `TIME_WAI`T을 통해 기다린다. (실질적인 종료과정 `CLOSED`에 들어가게 된다.)
            - 이때 `TIME_WAIT` 상태는 **의도치 않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지**
            - 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 `CLOSED`로 들어갑니다.
    - 서버는 ACK를 받은 이후 소켓을 닫는다 (Closed)
    - TIME_WAIT 시간이 끝나면 클라이언트도 닫는다 (Closed)
    
- **UDP**
    - **비연결형 서비스**를 제공한다.
    - **신뢰성, 흐름 제어, 혼잡 제어를 제공하지 않는다.**
    - 데이터그램 단위를 사용(독립적인 관계를 지니는 패킷)
    
    ![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%2010.png)
    

프로토콜 데이터 단위(PDU)는 **세그먼트(segment)**라고 불린다. 응용 계층에서는 메시지(message)였다.

## 3. 네트워크 계층

인터넷의 네트워크 계층은 한 호스트에서 다른 호스트로 **데이터그램(네트워크 계층 패킷)을 라우팅**하는 책임을 진다.

> **라우팅 : 데이터를 목적지까지 가장 빠르고 안전하게 전달하는 기능(최적 경로 선택)
포워딩 : 패킷이 라우터의 입력 링크로 들어오면, 해당 패킷을 적절한 출력 링크로 이동시키는 것**
> 

인터넷 전송 계층 프로토콜(TCP 혹은 UDP)은 전송 계층 세그먼트와 목적지 주소를 네트워크 계층으로 전달한다. 그리고 네트워크 계층에서는 이 전달받은 세그먼트를 목적지 네트워크 계층으로 운반하는 서비스를 제공한다.

프로토콜 데이터 단위(PDU)는 **패킷(packet)**라고 불린다.

### IP(Internet Protocol)

네트워크 계층에서 통신하는 주요 규칙 프로토콜이다.

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%2011.png)

헤더는 목적지와 출발지 IP 주소 등을 포함, 페이로드는 전송되는 데이터를 의미함.

## 2. 데이터 링크 계층

경로상의 한 노드(호스트 혹은 패킷 스위치)에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존해야 한다.

네트워크 계층에서 받아온 데이터그램을 프레임 단위로 만들고 **헤더와 트레일러**를 추가한다.

![Untitled](/assets/images/2024-03-19-OSI-7/Untitled%2012.png)

- 헤더 : 목적지, 출발지 주소 그리고 데이터 내용을 정의
- 트레일러 : 비트의 에러를 감지

프로토콜 데이터 단위(PDU)는 프레임**(frame)**라고 불린다.

## 1. 물리 계층

물리 계층은 프레임 내부의 각 비트를 한 노드에서 다음 노드로 이동하는 것이다.

이 계층의 프로토콜은 링크에 의존하고 더 나아가 링크의 실제 전송 매체(꼬임쌍선, 단일 모드 광케이블)에 의존한다.

참조

---

[프레임(Frame), 세그먼트(Segment) 모두 다 패킷(Packet)이다 - TCP/IP 작동 원리](https://timetolive.tistory.com/32)

[[네트워크] 캡슐화](https://dkswnkk.tistory.com/493)

[[네트워크] IP 계층(IP Layer) - IP 주소와 라우팅](https://velog.io/@redgem92/네트워크-IP-주소와-라우팅)

[[네트워크] TCP/UDP와 3 -Way Handshake & 4 -Way Handshake](https://velog.io/@averycode/네트워크-TCPUDP와-3-Way-Handshake4-Way-Handshake)