---
title: Operating system (6) CPU Scheduling - 2
excerpt: "CPU Scheduling - 2"

categories:
  - OS

permalink: /os/6/

toc: true
toc_sticky: true
 
date: 2024-03-09
last_modified_at: 2024-03-09
---
### 성능척도

- 이용률
- 처리율
- 사용자 입장에서의 성능척도
    - 소요시간, 반환시간(프로세스의 시작과 종료를 뜻하는게 아닌 프로세스가 레디큐에 들어와서 나가기까지의 시간만을 뜻함)
    - 대기시간(순수하게 줄서서 기다리는 시간)
    - 응답시간(레디큐에 들어와서 처음 cpu를 얻을때까지의 시간)

대기시간과 응답시간의 차이는 대기시간은 CPU를 넘겨주고 다시 Ready상태인 모든 시간을 합한것을 뜻하고 응답시간은 처음 들어와서 cpu를 얻을때까지의 시간을 뜻함

### FCFS(First-come First-Served)

- 먼저 온 순서대로 처리하는것
- 비선점형 구조
- 효율적이지 않다
- **CPU를 길게 쓰는 프로세스가 먼저 도착하면 비효율적임(Convoy effect).**

### SJF (Shortest-Job-First)

- **CPU burst time**이 가장 짧은 프로세스를 제일 먼저 스케줄
- **minnum average waiting time**을 보장
    - Nonpreemptive - 한번 CPU를 잡으면 이번 burst가 완료될 때까지 CPU를 빼앗기지 않음
    - Preemptive - 더 짧은 친구가 도착하면 뺏어서 넘겨줌 (SRTF)
        - 구체적으로 스케줄러는 문맥 교환을 수행할 수 있음. 실행 중인 프로세스를 잠시 중단시킬 수 있고, 다른 프로세스를 재개 및 시작시킬 수 있음.
        - 최단 잔여시간 우선(Shortest Time-to-Completion First, STCF) 또는 선점형 최단 작업 우선 (PSJF)으로 알려진 스케줄러
        - 작업의 길이를 미리 알고 있고, 작업이 오직 CPU만 사용하며, 평가 기준이 반환 시간 하나라면, STCF는 매우 훌륭한 정책이다.

- 문제점
    - CPU burst time이 엄청 긴 프로세스는 항상 후순위로 밀리는 문제가 있음(Starvation)
    - 여러 프로세스가 동시에 도착되었을때, 후순위로 갈수록 응답 시간(Response time)이 좋지 않다. (응답 시간 : 작업이 도착하고 스케줄될때까지의 시간)
    - CPU 사용시간을 미리 알 수 없음(추정은 가능)

### Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU를 주는것
- Nonpreemptive, Preemptive로 나뉠수 있음
- Solution : aging(노화) - 오래 기다린 프로세스는 우선순위를 조금씩 높여줌

### Round Robin (RR, time slicing)

라운드 로빈 스케줄링은 일정 시간 프로세스를 실행하고 실행 큐의 다음 작업으로 전환한다.

일정 시간 → time slice(scheduling quantam)

- 각 프로세스는 동일한 크기의 할당 시간(time slice)을 가짐
- 시간이 다되면 CPU를 뺏김
- 응답 시간이 짧아짐
- 기다리는 시간에 비례해서 Q TIME이 주어짐 (n-1)q time unit
- 이러한 **공정한 정책**(작은 시간 단위로 모든 프로세스에게 CPU를 분배함)은 **반환 시간과 같은 평가 기준에서는 성능이 나쁘다.**

### 멀티 레벨 피드백 큐(Multi-level Feedback Queue, MLFQ)

기본적인 방식은 여러개의 큐를 두어서 비어있지 않은 큐 중에 우선순위가 높은 큐 순서대로 처리하는 방식을 뜻함. 아래에서 설명하는 문제점을 해결하였을 때, 다음과 같은 규칙을 가진다.

- 규칙 1 : 우선순위 (A)> 우선순위 (B) 일 경우, A가 실행, B는 실행되지 않는다.
- 규칙 2 : 우선순위 (A) = 우선순위 (B), A와 B는 RR 방식으로 실행된다.
- 규칙 3 : 작업이 시스템에 들어가면 최상위 큐에 배치된다.
- 규칙 4 : 작업이 지정된 단계에서 배정받은 시간을 소진하면 (CPU를 포기한 횟수와
상관없이), 작업의 우선순위는 감소한다 (즉, 한 단계 아래 큐로 이동한다).
- 규칙 5 : 일정 주기 S 가 지난 후, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

### 문제점

- 기아 문제(starvation)
    - 상위 큐가 비어있지 않으면 하위 큐에 있는 프로세스는 CPU를 할당받을 수 없음
- 프로그램을 유리하게 작성
    - time slice의 99%를 진행하고 짧은 I/O 작업을 수행해 높은 큐에 계속 머물러있음
- 낮은 큐에서 작업이 진행되는 중에 I/O 작업을 많이 수행해야 할 경우

### 해결책

- Boost : 일정 기간 S 가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다. → 기아 문제와 낮은 큐에서의 I/O 문제를 해결할 수 있음
- MLFQ의 각 단계에서 CPU 총 사용 시간을 **측정 →** time slice 되기 직전에 우선순위 유지만을 위한 I/O작업을 넣는다고 해도 측정된 총 사용시간에 따라서 우선순위가 바뀌게 됨

---

참조

[운영체제 - 이화여자대학교 | KOCW 공개 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)