---
title: 디자인 패턴, 자바
excerpt: "study 1회차"

categories:
  - ETC

permalink: /etc/1/

toc: true
toc_sticky: true

date: 2024-03-13
last_modified_at: 2024-03-13
---

### 용어정리

- 라이브러리와 프레임워크는 공통으로 사용될 수 있는 특정 기능들을 모듈화한 것을 의미한다.
- 프레임워크는 프레임워크 자체가 제어 흐름의 주도성을 갖는 반면(제어의 역전), 라이브러리는 개발자가 가지고 있다.

## 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것.

개발하면서 발생하는 반복적인 문제들을 어떻게 해결할 것인지에 대한 해결 방안

### 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴. (인스턴스에 대한 전역 접근(액세스) 지점을 허용)

- 장점
    - 인스턴스를 생성하는 비용이 줄어듦
    - I/O Bound 작업에 주로 쓰임(네트워크 통신)
    디비에 대한 인스턴스를 하나 만들어서 연결해놓고 그 인스턴스에 여러 모듈을 연결해서 쿼리를 날리는 식
- 단점
    - 의존성이 높아진다.
    - **멀티 스레드** 적용 시 **동기화** 문제가 생길 수 있다.
    - 단일 책임 원칙, 개방 폐쇄 원칙을 위배한다.
        - 싱글톤 패턴은 하나의 클래스가 여러 가지 책임을 담당하게 되면서 **단일 책임 원칙(SRP)**을 위배할 수 있다. 싱글톤 클래스가 **생성, 관리, 전역 상태 유지 (수명주기)** 등 여러 가지 책임을 담당하게 되면, 클래스의 크기가 커지고 유지보수가 어려워진다.
        - Singleton은 무조건 단일 객체를 생성하여야 하며, 상속도 불가하기 때문에 확장성이 0에 가깝다. 따라서 **위반**된다. (OCP)

### 질문 리스트

- 싱글톤 패턴에 대해서 설명해주세요
- 싱글톤 패턴의 단점에 대해서 설명해주세요

### 팩토리 패턴

팩토리 메소드 패턴은 객체 생성을 공장 클래스로 캡슐화 처리하여 대신 생성하게 하는 생성 디자인 패턴입니다.

- 장점
    - 관심사항이 다른 코드를 하위 클래스로 분리해내고, 서로 독립적으로 변경 또는 확장할 수 있음
- 단점
    - 다중상속이 안됨. 이미 다른 목적을 위해 상속을 사용하고 있다면?
    - 상속을 통한 상하위 클래스의 관계는 생각보다 밀접함.

### 전략 패턴

객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 캡슐화한 알고리즘(전략)을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

- 장점
    - 개방 폐쇄 원칙을 지킬 수 있음, 응집력이 높고 결합도는 낮음

### MVC 패턴

MVC 패턴은 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴입니다.
애플리케이션의 구성 요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수있습니다.

- 모델은 애플리케이션의 데이터나, 상태나, 비지니스 로직을 뜻합니다
- 뷰는 사용자에게 제공되는 UI를 뜻합니다
- 컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 합니다

### 가비지 컬렉션

가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 부분을 자동으로 찾아서 해제하는 과정입니다.
JVM에서 가비지 컬렉션은 사용하지 않는 객체 인스턴스를 제거하기 위해 실행되는데, 그 전에 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되는 Stop The World 방식을 거칩니다.

작업이 중단되면, 사용되고 있는 메모리(Reachable)를 식별하는 작업인 Mark and Sweep 과정을 거치게 됩니다.

하지만 GC를 실행하는 비율이 많아질수록 Stop The World 과정도 더 많이 수행되어 심각한 오버헤드를 초래할 수 있는데, 이를 효율적으로 처리하기 위해 Young 영역과 Old 영역으로 Heap 영역을 나누어 관리합니다. 오래 살아남는 객체 인스턴스는 Young 영역에서 Old 영역으로 옮겨지고, Young영역에서만 Old보다 상대적으로 빈번히 제거되어 항상 전체 Heap 영역을 참조하여 GC가 이루어지지 않는다는 점에서 Stop The World의 오버헤드를 줄일 수 있었습니다.

이러한 오버헤드를 줄이기 위해 여러 가비지 컬렉션이 나왔고, 그중 G1 GC에서는 애플리케이션의 스레드를 멈추지 않고 동시에 진행할수 있고, Heap 영역을 여러 작은 영역(Region)으로 나누고 Young, Old 영역을 고정된 크기로 구분하지 않고 Region별로 구분하고 있습니다. 더 작은 단위로 메모리를 관리해 메모리 집적도를 높이고 Stop The World의 시간을 크게 줄일 수 있습니다.

### 자바의 메모리 영역

1) Method Area

- JVM이 실행되면서 생기는 공간이다.
- Class 정보, 전역변수 정보, Static 변수 정보가 저장되는 공간이다.
- Runtime Constant Pool 에는 말 그대로 '상수' 정보가 저장되는 공간이다.
- 모든 스레드에서 정보가 공유된다.

2) Heap

- new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
- Heap에 저장된 데이터는 Garbage Collector 가 처리하지 않는한 소멸되지 않는다.
- Reference Type 의 데이터가 저장되는 공간
- 모든 스레드에서 정보가 공유된다.

3) Stack

- 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
- Last In First Out, 나중에 들어온 데이터가 먼저 나간다
- 만약, 지역변수 이지만 Reference Type일 경우에는 Heap 에 저장된 데이터의 주소값을 Stack 에 저장해서 사용하게 된다.
- 스레드마다 하나씩 존재한다.

4) PC Register

- 스레드가 생성되면서 생기는 공간
- 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록한다.
- JVM이 실행하고 있는 현재 위치를 저장하는 역할

5) Native Method Stack

- Java 가 아닌 다른 언어 (C, C++) 로 구성된 메소드를 실행이 필요할 때 사용되는 공간

### String str ="i"와 String str = new String("i")가 동일합니까?

동일하지 않다. 리터럴로 생성한 객체는 Heap 메모리 내부의 상수 풀(String Constant Pool)에 별도로 저장되어 관리되기 때문에 최초 시도 이후에 똑같은 리터럴 값을 생성하려고 할 경우는 해당 메모리 주소를 반환한다. 하지만 new 연산자로 생성한 리터럴 값일 경우는 같은 리터럴 값이어도 새로운 객체를 생성하기 때문에 동일하지 않다고 본다.

단, == 연산자로 주소값을 확인하는것이 아닌 equals()를 사용하면 문자열 내용을 비교하기 때문에 true를 반환한다.